## Установка

Тестировалось только на Ubuntu 22.04

``` shell
git clone https://codeberg.org/strizhechenko/mqtt_automator.git /opt/mqtt/
apt install python3.11
python3.11 -m pip install -r /opt/mqtt/requirements.txt
cd /opt/mqtt/examples/config.yml.example /opt/mqtt/config.yml  # правим его под себя
cp -va /opt/mqtt/automator.service /etc/systemd/system/mqtt-automator.service
systemctl enable --now mqtt-automator
```

Если планируется делать доработки и делиться ими: лучше использовать pyenv с python3.11, я тестировал только на нём. Внутри virtualenv выполните:

``` shell
pip3 install -r requirements-dev.txt
pre-commit install-hooks
```

Запуск тестов:

``` shell
pytest  # параметры он прочитает из pyproject.toml
```

Запуск линтера:

``` shell
pylint  # параметры он прочитает из pyproject.toml
```

## Поддерживаемые устройства

- термостат Lytko 101
- рекуператоры Vakio Base Smart
- светильники Yeelink

## Почему не Home Assistant?

- Хотелось поразвлекаться с asyncio и сделать чудо-монолит
- Хотелось понимать, как управляются устройства под капотом
- У меня своеобразные хотелки в вопросе приоритета управления устройствами через физические кнопки
- Хотелось иметь максимально простой формат конфиг-файла, причём один на все устройства
- Оно потребляет всего 20мб оперативной памяти, разве не стоило велосипедов?

## Архитектура

В **одном потоке** уживаются **несколько** вечных асинхронных **тасок**. Это как треды/потоки, только задачи в терминологии asyncio.  За счёт того что я не строю хайлоад - они прекрасно уживаются и имеют **общее состояние**.  Скорее всего **есть баги конкурентности**, но ничего страшного от них не случится.

Таски:

1. **schedule** - расписание, эдакий cron для управления устройством, но с учётом его текущего состояния - лишние события, которые ничего не изменят, посылаться не будут.
2. **feedback** - построение изначального состояния устройств за счёт получения его от брокера при подписке на топики + обработка действий с устройством мимо этой системы - через пульты и кнопки, ручками. Ручные действия имеют приоритет над расписанием в течение 4 часов.

В целом проект придерживается **минимализма**. Небольшой файл в 40 строк - лучше, чем дополнительная зависимость на 1мб.

**Персистентного состояния** нет, если демон был перезапущен - он потеряет информацию о ручных действиях. Можно было бы держать эти словари (`devices.base.BaseClient.block`) в sqlite, postgresql или redis, но это кажется излишним усложнением.

## План развития

- [ ] В будущем хочу добавить простенький **веб-интерфейс** на aiohttp + jinja2 (в качестве третьей вечной таски), через который можно будет управлять устройствами.
- [ ] Оформить код как **библиотеку**, перенести `automator.py` внутрь неё. Это позволит стороннему пользователю установить её из pypi, импортировать `from $libname.automator import Automator`, `from $libname.devices.base import BaseClient`, реализовать клиент к **своему устройству** и добавить его в `Automator.client_map` между инициализацией и запуском.
- [ ] Дописать тесты к [движку правил](/application/config/parser.py).

## Происхождение

Изначально форк https://github.com/roppert/mosquitto-python-example.git, но от него не осталось почти ничего.
